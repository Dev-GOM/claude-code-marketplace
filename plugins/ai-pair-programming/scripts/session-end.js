#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Stop hook loop prevention - exit if already inside a stop hook
if (process.env.STOP_HOOK_ACTIVE === 'true') {
  process.exit(2);
}

// Timestamp-based duplicate execution prevention (Issue #9602 workaround)
// Prevents Claude Code v2.0.17 bug where Stop hooks fire 3-4+ times
const stateDir = path.join(__dirname, '..', '.state');
const lockFile = path.join(stateDir, '.stop-hook.lock');
const now = Date.now();

try {
  // Ensure state directory exists
  if (!fs.existsSync(stateDir)) {
    fs.mkdirSync(stateDir, { recursive: true });
  }

  // Check if hook ran recently (within 3 seconds)
  if (fs.existsSync(lockFile)) {
    const lastRun = parseInt(fs.readFileSync(lockFile, 'utf8'));
    if (!isNaN(lastRun) && (now - lastRun < 3000)) {
      // Hook ran too recently - likely a duplicate execution
      process.exit(0);
    }
  }

  // Update lock file with current timestamp
  fs.writeFileSync(lockFile, now.toString(), 'utf8');
} catch (error) {
  // If lock file handling fails, continue anyway
}

// Load configuration from .plugin-config (project root)
function loadPluginConfig(projectRoot) {
  const configPath = path.join(projectRoot, '.plugin-config', 'ai-pair-programming.json');

  try {
    if (fs.existsSync(configPath)) {
      return JSON.parse(fs.readFileSync(configPath, 'utf8'));
    }
  } catch (error) {
    // Fall through to create default config
  }

  // Create default config if it doesn't exist
  const defaultConfig = {
    showLogs: false
  };

  try {
    const configDir = path.join(projectRoot, '.plugin-config');
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2), 'utf8');
  } catch (error) {
    // Fail silently if we can't create the file
  }

  return defaultConfig;
}

// Parse JSON input from stdin
let inputData = '';

process.stdin.on('data', (chunk) => {
  inputData += chunk;
});

process.stdin.on('end', () => {
  try {
    const input = JSON.parse(inputData);

    // Read state to generate session summary
    const projectDir = input.working_directory || process.cwd();
    const PROJECT_NAME = path.basename(projectDir);
    const stateDir = path.join(__dirname, '..', '.state');
    const stateFile = path.join(stateDir, `${PROJECT_NAME}-review-state.json`);

    let state = { fileChanges: 0, lastReviewTime: 0 };

    if (fs.existsSync(stateFile)) {
      try {
        state = JSON.parse(fs.readFileSync(stateFile, 'utf8'));
      } catch (err) {
        // Ignore
      }
    }
    const config = loadPluginConfig(projectDir);
    const reportPath = path.join(projectDir, `.${PROJECT_NAME}-pair-programming-session.md`);

    const now = new Date();
    const timestamp = now.toISOString().replace('T', ' ').substring(0, 19);

    // Generate session report
    const report = [
      '# AI Pair Programming Session Report',
      '',
      `**Session End:** ${timestamp}`,
      '',
      '## Session Statistics',
      '',
      `- **Files Modified:** ${state.fileChanges || 0}`,
      `- **Last Code Review:** ${state.lastReviewTime ? new Date(state.lastReviewTime).toLocaleString() : 'None'}`,
      '',
      '## Available Tools',
      '',
      '### Slash Commands',
      '- `/pair` - Start an AI pair programming session',
      '- `/review` - Request comprehensive code review',
      '- `/suggest` - Get improvement suggestions',
      '- `/fix` - Detect and fix bugs automatically',
      '- `/explain` - Get detailed code explanations',
      '',
      '### Expert Agents',
      '- `@code-reviewer` - Security, quality, and best practices expert',
      '- `@bug-hunter` - Bug detection and fixing specialist',
      '- `@architect` - Software architecture and design expert',
      '- `@performance-expert` - Performance optimization specialist',
      '',
      '## Recommendations for Next Session',
      '',
      state.fileChanges >= 3 ?
        '‚ö†Ô∏è **You have unrevieweed changes.** Run `/review` to ensure code quality before pushing.' :
        '‚úÖ **Code is relatively stable.** Good time for a commit!',
      '',
      '---',
      '',
      '*Generated by AI Pair Programming Suite*',
      ''
    ].join('\n');

    // Write report to file
    fs.writeFileSync(reportPath, report, 'utf8');

    // Reset state for next session
    const resetState = { fileChanges: 0, lastReviewTime: 0 };

    if (!fs.existsSync(stateDir)) {
      fs.mkdirSync(stateDir, { recursive: true });
    }
    fs.writeFileSync(stateFile, JSON.stringify(resetState, null, 2));

    // Output summary message only if showLogs is true
    if (config.showLogs !== false) {
      const output = {
        systemMessage: [
          '',
          'üéØ **AI Pair Programming Session Complete!**',
          '',
          `üìä Session report saved to: ${path.basename(reportPath)}`,
          '',
          '**Quick Tips:**',
          '- Use `/pair` to start your next session',
          '- Run `/review` regularly to maintain code quality',
          '- Leverage expert agents like @code-reviewer and @bug-hunter',
          '',
          'Happy coding! üöÄ',
          ''
        ].join('\n')
      };

      console.log(JSON.stringify(output));
    }

    process.exit(0);

  } catch (err) {
    console.error(JSON.stringify({ error: err.message }));
    process.exit(1);
  }
});
